# 사람은 나이, 키, 몸무게로 구성된다
# 오름차순 기준, 그리고 0 번째 존재
# 갑 : 나이 1번째, 키 0번째, 몸무게 3번째
# 을 : 나이 1번째, 키 1번째, 몸무게 2번째
# 병 : 나이 0번째, 키 2번째, 몸무게 1번째
# 정 : 나이 0번째, 키 2번째, 몸무게 0번째

# persons는 갑,을,병,정의 구성정보
persons=[(30,171,54,'갑'),(30,172,53,'을'),(20,173,52,'병'),(20,174,51,'정')]

# 질문 1 : 어떻게 하면 모든 구성요소별로 오름차순하는것인가?

# 1변수 정렬; 1순위 '나이' 기준 오름차순
print(sorted(persons,key=lambda person : person[0]))
#[(20, 173, 52, '병'), (20, 174, 51, '정'), (30, 171, 54, '갑'), (30, 172, 53, '을')]

'''
?어떻게 하는 것일까?
나이만 생각해서 간단히 C로 구현된 버블정렬로
persons의 인덱스를 변경하면됨

(아래는 개괄적인 구현과정임)
persons[1]=persons[2]
persons[0]=persons[1]

당연히 키와 몸무게는 고려X
'''

# 2변수 정렬; 1순위 '나이' 기준 오름차순, 2순위 '키' 기준으로 오름차순
print(sorted(persons,key=lambda person : (person[0],person[1]) ))
#[(20, 173, 52, '병'), (20, 174, 51, '정'), (30, 171, 54, '갑'), (30, 172, 53, '을')]

'''
?어떻게 하는거지?
우선 위 1변수 정렬을 시행했다고하면, 위와같이, 병 => 정 => 갑 => 을 순임
근데 '병과 정'을 추가로 키를 기준으로 정렬해야함

여기서 궁금한게, 아마도
병 => 정 => 갑 => 을  ; [(20, 177, 52, '병'), (20, 176, 51, '정'), (30, 179, 54, '갑'), (30, 179, 53, '을')]
순으로 정렬된 상태를 기반으로 2번째 정렬이 발생할것같은데

눈으로야 persons에서 0번째와 1번째만 서로 비교해서 '정이 더 작구나! 너가 앞으로', 2번째와 3번째 비교해서 '갑과 을 서로 같네 그대로 있어'
하면되지만

내가 만약 C로 저 sorted(persons,key=lambda person : (person[0],person[1]) )를 구현할때,

'병과 정', 그리고 '갑과 을'만 서로 비교하기 위해선 인덱스 0은 1과만, 2는 3과만 키를 기준으로 비교하세요 라고 코딩하지 않는 이상

2순위인 키를 기준으로 정렬할때도, 갑~정 모두 한꺼번에 비교해야함.
여기서 궁금한게, 정말 단순무식하게 1변수 정렬결과의 규칙성을 고려하지 않고 '2순위만' 고려하면
즉, print(sorted(persons,key=lambda person : (person[1]) )) 하면
[(30, 171, 54, '갑'), (30, 172, 53, '을'), (20, 173, 52, '병'), (20, 174, 51, '정')]

으로서 정렬 시 1순위인 나이가 무시됨,

1변수 정렬된 결과의 규칙성을 유지하면서, 2순위 키를 기준으로 또 오름차순할려면

C로 코딩을 어떻게 해야하는지 궁금합니다

'''


# 3변수 정렬; 1순위 '나이' 기준 오름차순, 2순위 '키' 기준 오름차순, 3순위 '몸무게' 기준 오름차순
print(sorted(persons,key=lambda person : (person[0],person[1],person[2]) ))
#[(20, 173, 52, '병'), (20, 174, 51, '정'), (30, 171, 54, '갑'), (30, 172, 53, '을')]