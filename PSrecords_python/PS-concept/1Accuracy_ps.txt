1. 문제를 정확히 이해하고 컴퓨터 변수로 대응
동시발생을 1개씩 쪼개고
매트릭스를 그래프로 이해하고

search space를 도출; 문제 해결을 위해 고려해야하는 모든 경우
가령, n*n 정사각형 내에서 만들수있는 정사각형 수는?
1) 1*1 정사각형 ; 
2) 2*2 정사각형 ; 
..
..
n) n*n
# 케이스 단위
-> 1+..+n = n(n+1)/2 => 시간복잡도 O(n2)

2. 알고리즘 개발 및 설계

주요 알고리즘; 
brute force(일단 전체를 구하고 답을 구하는것), divide and conquer, dynamic programming,
greedy approach(부분 내에서 최적을 찾는것), graph algorithm


3. 알고리즘 증명

4. 제한 시간 내에 작동할수 있음

5. 코드화

6. 보완



키워드;조건, 변수 및 변수 생성
문제이해와 알고리즘

! 변수 범위 필수 체크 ->greedy하게 풀지, parameter쓸지 고민할때,
L10_09문제
이 경우, 연산이 불필요한 부분도 있고 i가 겁나크니까 대충 후자
->wrong!!!!

i가 겁나 커서 막연히 전체 구간 훑으면 큰일 날쭐 알았는데,
n자체는 작고 구간이 일정한 간격(1)로 생성되서 이런 패턴에 근거하면
비록
 o(n)이지만 큰 타격이 없고, 그냥 전체 구간 훑어도된다.

 한편, 시간복잡도를 고민해서 정렬의 필요성을 가늠해야.(nlogn)
(가령)
큰틀은 parameter bs; logN
그리고
전체 구간 N개에 대해서 start,end추출하고
주어진값과 비교하여 그것보다 작거나 같은 수 갯수 연산;N

=>logN(N)

우선 전체 구간 N을 정렬;NlogN
이 다음에
큰틀은 parameter bs;logN
그리고
start가 너무 커서 쓸모없는 구간 색출;parameter bs형태->logN
그리고 N보단 작은 N'구간에 대해 같은 작업;N'

NlogN+logN(logN+N')
=logN(logN+N')

N>N'
==============

step1
 로직 생각, 참고로 완벽세련보단 느슨근사 그러나 빈틈없이
 변수 정의 그리고 받기; '정수계 or 실수계' 좌표, 간격; dy dx
 필요변수 만들기 ex list_parameters

step2
 필요 함수 구현


!문제를 잘 읽자! -> 잘 적자 이게 베스트, 특히 변수 범위
중간에야 '서로다른' 숫자임을 파악해서 중간 부터는 코드가 간소화됬지만
정작 totalcases가 중복을 허용한 케이스라 오답발생

처음부터 잘 읽고 문제 확인하면 다 체크해야...변수 마인드맵을 그리기도 하고

!만약 딱 맞는 변수들을 만들기 힘들다면 좀더 넓게나 좁게 만들고 추후 조정!
서로다른 3자리로 이루어진 3자릿수->중복이 허용된 서로다른 3자릿수 후 쳐내기

근데 일단 연습중에는 최대한 맞게 짜내야지

!변수 마인드맵 겸 변화단계 표 작성해서 타이밍 고려해

ex)

    cnt_peel=2

    while(cnt_beehouses>=N):
        cnt_beehouses=3*(cnt_peel**2)-3*(cnt_peel)+1
        cnt_peel+=1

의 경우

cnt_peel 2 3 4
~         7 

! 빡치게 0번째부터 세는 문제가 있다->a0의 출현 from 피보나치 수열

! 예제에 맞춰서 로직짜는건 어쩔수 없는데 되도록 일반화까지 염두해야
가령 예제에서 N=4일때는     total=matrix[0][1]+matrix[N-2][N-1]
가 맞지만 5이상부터는 다른 공식

! 손으로 풀때 수학과, 컴퓨터 기입 시 격차 유의->()필수
    val_total=sum_matrix / 2*(N-1); 읽으면서 내 상상으로는 분모에 N-1을 곱했지만 실제로는 아래와 같이
->
    val_total=sum_matrix / (2*(N-1))

! 수열 패턴문제는 
*점화식 참고;https://m.blog.naver.com/PostView.nhn?blogId=freewheel3&logNo=220846174457&proxyReferer=https:%2F%2Fwww.google.com%2F
1단위, 홀수단위, 짝수단위라는 기본에 충실하자
+대칭조건도 있다면 유념하자
+갯수차원에서도 분석
+DP

121312141213121
5
121312141213121
=
(5
4 4
33 33
2222 2222
11111 11111)*2쯤
=
1213121;3일때 출력값
4
1213121
5
1213121
4
1213121

! 조건의 최우선 레이어를 만들어라; L3_09

! 타임리밋해결; 최종적으론 그리디를 해야한다고 해도, 일단 우선선별 과정을 통해서 시간소요 최소화

! 이진탐색은 빠르게 근사값을 찾아가는 데에도 활용가능하구나, 그리디보다 우선할 필요있다.

! 변수간 연관성; 비례 반비례는 up down으로 표기; L10_06

! 중간 결과들에 대한 패턴분석 필요,
주사위게임이랑, fmttalpha

! if보단 while을 우선해라,
예시의 경우 3개 이상에 대해서 보여주지 않고,
대개 좀 복잡해지면 그 규칙이 주어진 예시의 2개 이하가 아니라
3번이상 반복되면 2중 if로는 커버가 안된다.

! 주어진 입력값이 스택값같은 역순일 수 있는 것도 고려해야할듯

! tree 포함 그래프에서 간선에서 양방향시 양쪽 노드에 모두 경로가 있어야 한다.