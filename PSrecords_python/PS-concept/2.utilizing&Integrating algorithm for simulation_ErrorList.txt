0. 무명의 오류... , L6_08, 무작위 테스트케이스 대입

당최 어떤 케이스에서 불충족인지 감이 안올때는 운에 맞기도 케이스 대입해야
L6_08문제에서 왠지 모르게 80점 나옴, 그냥 ABBCCCDDDDCCCBBA대입해보니,
마지막이 ABBCCCDDDDCCCBBB라면 생기지 않을 문제가
마지막에 반복이 끝날때 생기는 문제를 발견함.

[(1, 'A'), (2, 'B'), (3, 'C'), (4, 'D'), (3, 'C'), (2, 'B'), (1, 'B')]
A2B3C4D3C2BB

최악의 경우는 이렇게 대뜸 대입해야

####
1. '2개 이하'의 오류,L3maxofarr , 3개 이상을 생각하자

조건들의 레이어를 점검하고, 내 로직이 이걸 다 준수하나 확인하고 이를 위해선 특정 조건이 0,1,2를 넘어 3이상부터 점검; 
최댓값이 두 개 이상인 경우 그 중 행의 번호가 가장 작은 곳의 위치를 출력한다. 행 번호도 같은 곳이 여러개일 경우에는 열 번호가 가장 작은 곳의 위치를 출력한다.
->'모든 경우'에 대해서 일단 행이 우선 그 다음 칼럼

내 테스트 케이스

3 23 85 34 17 74 25 52 65
10 7 39 42 88 52 14 72 63
87 42 18 78 53 45 18 84 53
34 28 64 85 12 16 75 36 55
21 77 45 35 28 75 90 76 1
25 87 65 15 28 11 37 28 74
65 27 75 41 7 89 78 64 39
47 47 70 45 23 65 3 41 99
87 13 82 38 31 12 29 99 80

찾고자 하는 99가 2개이고, 두 개가 공통된 특징을 가질때(가령 원점으로부터 거리가 같음)
그 다음 행을 우선하게 설정
->근데 3개라면?

3 23 85 34 17 74 25 52 65
10 7 39 42 88 52 14 72 63
87 42 18 78 53 45 18 84 53
34 28 64 85 12 16 75 36 55
21 77 45 35 28 75 90 76 1
25 87 65 15 28 11 37 28 74
65 27 75 41 7 89 78 64 99
47 47 70 45 23 65 3 99 44
87 13 82 38 31 12 99 29 80

내 로직은 원점으로부터의 거리-> 3가지 99에 대해서 동일하게 판단
그러나, 이 다음 행을 우선하게 하는 로직에서 2개일때만 따지게하다보니까
8행 8열이 출력됨,

문제 요구는 7행 9열인데(왜냐하면 행이 모든 경우에 대해서 우선하니까)
결론, 3개 이상을 기본으로 하자.

####
2. 과다 체크, L10_08 noduplicate
해석 :cnt가 2개 이상이면 체크 => 2개가 되면 1번 체크해야되는데 2개가 된 케이스가 3개 4개가 될때마다 과다 체크
사람이었다면, 아까 체크한거자나! 이러면서 넘겼겠지만, 컴퓨터는 아니다! 이와같은 걸 기대할려면 또 변수선언필요

숫자를 1개씩 가져와서 입력받는 상황에서, 즉 과정중 관찰 및 처리
숫자별 빈도수를 저장하는 test list에 2개, 3개, 4개 등 '2개 이상' 중복된 숫자가 있다면
부적합 판정을 내려야하는 상황이다.

나는 여기서 '2개 이상', 중복'이란 키워드 속에서 아래와 같이 코드를 연상했다. 

                    if(test_list[seqs[i]-1]>=2):
                        cnt_2+=1

그러나 이는 결과에 대한 관찰 및 처리 코드와 과정중 코드가 섞인 불순코드이다.

                    if(test_list[seqs[i]-1]==2):
                        cnt_2+=1

애당초 1개씩 입력받는 과정에서는 전체코드가 갱신되는 과정이라 
현재 들어온 숫자와 그 숫자의 test_list 속 빈도수가 계속 갱신되는 과정이라
저렇게 결과에 대한 if문을 적용하면 에러가 생긴다.

가령, 1 1 3과 같이 1이 연달아서 들어왔다가 다른 숫자가 나오면 상관없다.
근데 만약 1 1 1 5 이라면 1의 빈도 수는 3개이고 5의 갯수는 1개이고, 중복된 발생 횟수는 2번이나,
위 코드는 3번을 카운팅한다, 1 1-> cnt_2 1증가, 후 1들어오면 cnt_2 또 1증가

한편, testlist가 완전히 갱신된다음이라면

for element in ~:
    if(element>=2)꼴도 맞긴하다.

####
3. 문법 이해 및 활용 미숙
인덱스 기준; (i+1)%10과 (i%10)+1의 차이