! 역으로 생각하기+'반드시' 도달가능한 값을준다
20이 1에 도달할수있을지 모르는데, 조건상 주어진조건들을
*2=>/2
/3하고 버리기 => 3곱하기, 그리고 나머지 후보들 더하기

역으로 적용시 접근가능하다고한다.
그렇다면 
20에서 1을 가자 빠르게 가는 법, 즉 작아지는 것은
/2이다

20
10
5

5에 도달하면 이것은 1에 주어진 연산들을 한 결과인데, 
소수점을 버린다는 조건으로 인해 2.5는 후보에서 제외되고
나머지 후보들은
15/16/17

이다.

여기서 또 후보를 탈락시킬수 있다.
15가 7.5가 아닌 45에서 왔을 수 있다. 그러나 같은 층위에 이미 16이 있는 상황에서
45는 최단거리가 될수없다. 당장이라도 나누기2를해서 거리를 좁혀야할 마당에
*3으로 값이 커지면 거리가 멀어지기 때문이다.

즉, 여기서 가장 가까운 노드는 16뿐이고
8
4
2
1
이다.

이러한 패턴을 활용하면 최단 이동거리를 도출할수있다.
참고로 아래와같이 n에 따라 후보들이 2의 배수가 되는지 안되는지 결정되므로,
결국 다 해봐야한다.
3n  ; 현재 n에 곱하기 3한거니, 2의 배수가 될리가 없다 
3n+1=2(n+1)+n-1
3n+2=2(n+1)+n

일단 3n+1,3n+2가 그나마 최단거리 후보이다.
근데 현재 n은 짝수가 아니라서 이짓거리를 하는거라 n = 2k+1로 정의가능하다
3(2k+1)+1=6k+4=2(3k+2)
3(2k+1)+2=6k+5

로 3개의 후보 중 1개는 반드시 짝수여야만한다.

! bfs는 주어진 그래프를 활용하는 게 기존이지만,
이 로직을 활용해서 길을 만들 수 있다. 그것이 대표적인 완전탐색에 bfs/dfs를 활용하는 기법이다.
즉, 현상을 그래프로 차원으로 이동해서, 혹은 간주해서 문제를 푸는 것이다.

==
50점 나옴, 아마도 다익스트라처럼 풀어야할 듯하다

일단 내가 생각한 길이 최적이 아니라는 건데....
무작위로 반례는 찾음
1 2 4 8 16 32 64 21 7

그냥 나누기 3을 2번하는 것이 빠른 경우가 분명 있음.
결국 수학적인 이해는 잘했으나, 전체 패턴을 찾은 것은 아니었음

애당초 내가 노드와 노드 사이 1번만 고려해서 패턴을 좁게 봤음.
노드와 노드 그리고 노드로 연산이 2번되면 또 새로운 영향이 발생
즉 일단은 3곱하고, 그다음 3n+1이 이득인 경우가 있었다.
분명 최종점은 3n+1이 되긴해야하네